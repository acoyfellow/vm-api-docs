<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VM API - exe.dev Agent Orchestration</title>
  <meta name="description" content="Documentation for the exe.dev agent orchestration system. Worker loops, memory, handoff recovery, and more.">
  <style>
    :root {
      --bg: #0d1117;
      --surface: #161b22;
      --border: #30363d;
      --text: #c9d1d9;
      --text-muted: #8b949e;
      --accent: #58a6ff;
      --green: #3fb950;
      --yellow: #d29922;
      --red: #f85149;
    }
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      line-height: 1.6;
      margin: 0;
      padding: 0;
    }
    .container {
      max-width: 900px;
      margin: 0 auto;
      padding: 2rem;
    }
    h1 {
      color: #fff;
      font-size: 2.5rem;
      margin-bottom: 0.5rem;
      border-bottom: 1px solid var(--border);
      padding-bottom: 1rem;
    }
    h1 span { color: var(--accent); }
    .subtitle {
      color: var(--text-muted);
      font-size: 1.1rem;
      margin-bottom: 2rem;
    }
    h2 {
      color: #fff;
      font-size: 1.5rem;
      margin-top: 3rem;
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid var(--border);
    }
    h3 {
      color: var(--accent);
      font-size: 1.1rem;
      margin-top: 1.5rem;
    }
    p { margin: 1rem 0; }
    code {
      background: var(--surface);
      padding: 0.2em 0.4em;
      border-radius: 4px;
      font-size: 0.9em;
      font-family: 'SF Mono', Consolas, monospace;
    }
    pre {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem;
      overflow-x: auto;
      position: relative;
    }
    pre code {
      background: none;
      padding: 0;
      font-size: 0.85rem;
    }
    .copy-btn {
      position: absolute;
      top: 0.5rem;
      right: 0.5rem;
      background: var(--border);
      border: none;
      color: var(--text-muted);
      padding: 0.3rem 0.6rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.75rem;
    }
    .copy-btn:hover { background: var(--accent); color: #fff; }
    .card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1.5rem;
      margin: 1rem 0;
    }
    .card h3 { margin-top: 0; }
    .badge {
      display: inline-block;
      padding: 0.2em 0.6em;
      border-radius: 4px;
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
    }
    .badge-tool { background: var(--accent); color: #000; }
    .badge-script { background: var(--green); color: #000; }
    .badge-api { background: var(--yellow); color: #000; }
    .toc {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1.5rem;
      margin: 2rem 0;
    }
    .toc h3 { margin-top: 0; color: var(--text-muted); font-size: 0.9rem; }
    .toc ul { margin: 0; padding-left: 1.5rem; }
    .toc li { margin: 0.5rem 0; }
    .toc a { color: var(--accent); text-decoration: none; }
    .toc a:hover { text-decoration: underline; }
    .warning {
      background: rgba(248, 81, 73, 0.1);
      border-left: 3px solid var(--red);
      padding: 1rem;
      margin: 1rem 0;
      border-radius: 0 8px 8px 0;
    }
    .tip {
      background: rgba(63, 185, 80, 0.1);
      border-left: 3px solid var(--green);
      padding: 1rem;
      margin: 1rem 0;
      border-radius: 0 8px 8px 0;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1rem 0;
    }
    th, td {
      text-align: left;
      padding: 0.75rem;
      border-bottom: 1px solid var(--border);
    }
    th { color: var(--text-muted); font-weight: 600; }
    footer {
      margin-top: 4rem;
      padding-top: 2rem;
      border-top: 1px solid var(--border);
      color: var(--text-muted);
      font-size: 0.9rem;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>VM <span>API</span></h1>
    <p class="subtitle">Documentation for the exe.dev agent orchestration system</p>
    
    <div class="toc">
      <h3>TABLE OF CONTENTS</h3>
      <ul>
        <li><a href="#worker-loops">Worker Loops</a> — autonomous agent sessions with handoff</li>
        <li><a href="#handoff-recovery">Handoff Recovery</a> — automatic context preservation</li>
        <li><a href="#deja-memory">Deja Memory</a> — persistent cross-session memory</li>
        <li><a href="#session-search">Session Search</a> — search past conversations</li>
        <li><a href="#context-management">Context Management</a> — control the context window</li>
        <li><a href="#conversation-management">Conversation Management</a> — archive, cancel, status</li>
        <li><a href="#api-reference">API Reference</a> — HTTP endpoints</li>
        <li><a href="#health-checks">Health Checks</a> — automated build gates</li>
        <li><a href="#orchestrator">Orchestrator</a> — lifecycle coordination</li>
      </ul>
    </div>

    <!-- WORKER LOOPS -->
    <h2 id="worker-loops">Worker Loops <span class="badge badge-script">~/bin/worker</span></h2>
    
    <p>Autonomous agent sessions that run until complete or hitting context limits. Sessions hand off state to the next session automatically.</p>
    
    <h3>Start a loop</h3>
    <pre><code>worker start &lt;name&gt; --task "description of work" --dir /path/to/project [--max 10]</code></pre>
    
    <h3>Check running loops</h3>
    <pre><code>worker list</code></pre>
    <p>Shows all workers with status, session count, and working directory.</p>
    
    <h3>Stop a loop</h3>
    <pre><code>worker stop &lt;name&gt;       # graceful stop
worker stop-all          # stop everything</code></pre>
    
    <h3>View logs</h3>
    <pre><code>worker log &lt;name&gt;        # show recent output
tail -f ~/.workers/&lt;name&gt;.log  # live tail</code></pre>
    
    <h3>Adjust running worker</h3>
    <pre><code># Change max sessions on a running worker
worker adjust &lt;name&gt; --max 50

# Example: bump orchestrator from 10 to 50 sessions
worker adjust orchestrator --max 50</code></pre>
    
    <div class="card">
      <h3>Key behaviors</h3>
      <table>
        <tr><th>Feature</th><th>Behavior</th></tr>
        <tr><td>Context limit</td><td>Stops at 75% context, extracts handoff, starts next session</td></tr>
        <tr><td>Handoff extraction</td><td>Queries SQLite for last think blocks, injects into next session</td></tr>
        <tr><td>Directory lock</td><td>Only one worker per directory (prevents conflicts)</td></tr>
        <tr><td>State file</td><td><code>~/.workers/&lt;name&gt;.json</code></td></tr>
        <tr><td>Deja integration</td><td>Queries deja for project memories at session start</td></tr>
      </table>
    </div>
    
    <div class="tip">
      <strong>Steering a running loop:</strong> Update deja memories. The agent queries deja at each session start, so new memories steer direction.
    </div>

    <!-- HANDOFF RECOVERY -->
    <h2 id="handoff-recovery">Handoff Recovery</h2>
    
    <p>When a session ends (context limit, interruption, or natural completion), the orchestrator extracts state and injects it into the next session.</p>
    
    <h3>How it works</h3>
    <ol>
      <li>Session hits context limit or is interrupted</li>
      <li>Orchestrator cancels the session</li>
      <li>Orchestrator queries SQLite for last 3 <code>think</code> tool calls</li>
      <li>Extracts HANDOFF: or DONE: from last text message</li>
      <li>Injects extracted context into next session prompt</li>
    </ol>
    
    <h3>Handoff types</h3>
    <table>
      <tr><th>Type</th><th>Source</th><th>Result</th></tr>
      <tr><td><code>DONE:</code></td><td>Agent's last message</td><td>Worker marks complete, stops</td></tr>
      <tr><td><code>HANDOFF:</code></td><td>Agent's last message</td><td>Message injected into next session</td></tr>
      <tr><td>Interrupted</td><td>Last think blocks</td><td>Thoughts summarized and injected</td></tr>
    </table>
    
    <h3>SQLite extraction</h3>
    <pre><code># What the orchestrator queries:
sqlite3 ~/.config/shelley/shelley.db "
  SELECT json_extract(json(llm_data), '$.Content[0].ToolInput.thoughts')
  FROM messages 
  WHERE conversation_id='CONV_ID' 
    AND json_extract(json(llm_data), '$.Content[0].ToolName') = 'think'
  ORDER BY sequence_id DESC LIMIT 3
"</code></pre>
    
    <div class="tip">
      <strong>Best practice:</strong> Use the <code>think</code> tool to record your reasoning. These thoughts are preserved across session boundaries.
    </div>

    <!-- DEJA MEMORY -->
    <h2 id="deja-memory">Deja Memory <span class="badge badge-api">deja.coey.dev</span></h2>
    
    <p>Persistent memory that survives across sessions. Worker loops automatically query deja at session start.</p>
    
    <h3>Query for relevant memories</h3>
    <pre><code>curl -s -X POST https://deja.coey.dev/inject \
  -H "Content-Type: application/json" \
  -d '{"context": "describe your task", "format": "prompt", "limit": 5}'</code></pre>
    <p>Returns learnings relevant to the context. Worker loops do this automatically.</p>
    
    <h3>Store a learning</h3>
    <pre><code>curl -s -X POST https://deja.coey.dev/learn \
  -H "Authorization: Bearer $(cat ~/.deja-api-key)" \
  -H "Content-Type: application/json" \
  -d '{
    "trigger": "when this is relevant",
    "learning": "what to remember",
    "confidence": 0.9
  }'</code></pre>
    
    <div class="warning">
      <strong>Don't pollute deja:</strong> Running tests against deja created 48 garbage entries that drowned out 13 real ones. Use unique markers and clean up after tests.
    </div>
    
    <h3>Memory types</h3>
    <table>
      <tr><th>Type</th><th>Use for</th></tr>
      <tr><td>Project state</td><td>Current status, blockers, next steps</td></tr>
      <tr><td>Learnings</td><td>"When X happens, do Y" patterns</td></tr>
      <tr><td>Failures</td><td>Things that didn't work (prevent repeats)</td></tr>
    </table>

    <!-- SESSION SEARCH -->
    <h2 id="session-search">Session Search <span class="badge badge-script">~/bin/shelley-*</span></h2>
    
    <p>Past shelley sessions are searchable. Find what you tried before.</p>
    
    <h3>Search past sessions</h3>
    <pre><code>~/bin/shelley-search "pattern" [limit]</code></pre>
    <p>Finds conversations mentioning the pattern, shows context snippets.</p>
    
    <h3>Get compact context for injection</h3>
    <pre><code>~/bin/shelley-recall "error message" [limit]</code></pre>
    <p>Returns HANDOFF notes and relevant snippets, formatted for prompt injection.</p>
    
    <div class="tip">
      <strong>Auto-recall in health checks:</strong> When <code>gates/health.sh</code> finds errors, it can auto-search past sessions and include relevant context.
    </div>

    <!-- CONTEXT MANAGEMENT -->
    <h2 id="context-management">Context Management <span class="badge badge-script">~/bin/ctx</span></h2>
    
    <p>Selective editing of the context window. Delete tool outputs you don't need anymore.</p>
    
    <h3>Check context size</h3>
    <pre><code>ctx size &lt;conversation_id&gt;</code></pre>
    
    <h3>Search for messages</h3>
    <pre><code>ctx search &lt;conversation_id&gt; "search term"</code></pre>
    <p>Returns message IDs matching the term.</p>
    
    <h3>Delete messages</h3>
    <pre><code>ctx forget &lt;msg_id&gt; [msg_id...]</code></pre>
    
    <h3>List recent messages</h3>
    <pre><code>ctx list &lt;conversation_id&gt; [limit]</code></pre>
    
    <div class="card">
      <h3>Workflow: "forget the websocket stuff"</h3>
      <ol>
        <li><code>ctx search &lt;conv&gt; "websocket"</code> — find message IDs</li>
        <li><code>ctx forget id1 id2 id3</code> — delete them</li>
        <li><code>ctx size &lt;conv&gt;</code> — verify tokens freed</li>
      </ol>
    </div>

    <!-- CONVERSATION MANAGEMENT -->
    <h2 id="conversation-management">Conversation Management <span class="badge badge-script">~/bin/conv</span></h2>
    
    <p>Manage conversations programmatically. Archive, cancel, check status.</p>
    
    <h3>List conversations</h3>
    <pre><code># All conversations
conv list

# Only currently working (actively processing)
conv list --working</code></pre>
    
    <h3>Check status</h3>
    <pre><code>conv status &lt;id|slug&gt;

# Example output:
# ID:       cSJ3NR3
# Slug:     orchestrator
# Model:    claude-opus-4.5
# Archived: false
# Context:  26561 tokens</code></pre>
    
    <h3>Archive/Unarchive</h3>
    <pre><code># Archive a conversation (hides from list)
conv archive orchestrata

# Bring it back
conv unarchive orchestrata</code></pre>
    
    <h3>Cancel</h3>
    <pre><code># Stop a running conversation
conv cancel &lt;id|slug&gt;</code></pre>
    
    <div class="tip">
      <strong>Tip:</strong> Use partial slug matches. <code>conv status orch</code> finds "orchestrator".
    </div>

    <!-- API REFERENCE -->
    <h2 id="api-reference">API Reference <span class="badge badge-api">localhost:9999</span></h2>
    
    <p>HTTP endpoints for conversation management. All require <code>X-Exedev-Userid</code> header.</p>
    
    <table>
      <tr><th>Method</th><th>Endpoint</th><th>Description</th></tr>
      <tr><td>GET</td><td><code>/api/conversations</code></td><td>List all conversations (includes <code>working</code> field)</td></tr>
      <tr><td>GET</td><td><code>/api/conversation/{id}</code></td><td>Get conversation details + <code>context_window_size</code></td></tr>
      <tr><td>POST</td><td><code>/api/conversation/{id}/archive</code></td><td>Archive a conversation</td></tr>
      <tr><td>POST</td><td><code>/api/conversation/{id}/unarchive</code></td><td>Unarchive a conversation</td></tr>
      <tr><td>POST</td><td><code>/api/conversation/{id}/cancel</code></td><td>Cancel a running conversation</td></tr>
    </table>
    
    <h3>Example: Check if conversation is running</h3>
    <pre><code>curl -s "http://localhost:9999/api/conversations" \
  -H "X-Exedev-Userid: $USER" | jq '.[] | select(.working == true)'</code></pre>
    
    <h3>Example: Get context size</h3>
    <pre><code>curl -s "http://localhost:9999/api/conversation/cSJ3NR3" \
  -H "X-Exedev-Userid: $USER" | jq '.context_window_size'
# 26561</code></pre>

    <!-- HEALTH CHECKS -->
    <h2 id="health-checks">Health Checks <span class="badge badge-tool">gates/health.sh</span></h2>
    
    <p>Worker loops auto-run <code>gates/health.sh</code> before each session. Output is injected into the prompt.</p>
    
    <h3>Create a health check</h3>
    <pre><code>#!/bin/bash
# gates/health.sh - exit 0 = healthy, exit 1 = blockers

# Type check
ERRORS=$(npx tsc --noEmit 2>&1 | grep "error TS" | head -10)
if [ -n "$ERRORS" ]; then
  echo "❌ Type errors - FIX FIRST:"
  echo "$ERRORS"
  exit 1
fi

echo "✅ Build passes"
exit 0</code></pre>
    
    <h3>What to check</h3>
    <table>
      <tr><th>Check</th><th>Blocking?</th><th>Why</th></tr>
      <tr><td>Type errors</td><td>Yes</td><td>Don't add features on broken builds</td></tr>
      <tr><td>Uncommitted changes</td><td>Yes</td><td>Commit before doing more work</td></tr>
      <tr><td>Explicit <code>any</code></td><td>Yes</td><td>Use specific types</td></tr>
      <tr><td>TODO markers</td><td>No</td><td>Awareness, not blocking</td></tr>
      <tr><td>console.log</td><td>No</td><td>Clean up eventually</td></tr>
    </table>

    <!-- ORCHESTRATOR -->
    <h2 id="orchestrator">Orchestrator</h2>
    
    <p>The orchestrator coordinates run lifecycle. It does not manage agent reasoning mid-session. It handles boundaries and recovery.</p>
    
    <h3>Responsibilities</h3>
    <ul>
      <li><strong>Start/stop runs:</strong> Manages worker lifecycle</li>
      <li><strong>Enforce limits:</strong> Cancels sessions at 75% context</li>
      <li><strong>Extract handoffs:</strong> Queries SQLite for think blocks after cancellation</li>
      <li><strong>Inject context:</strong> Passes handoff + deja memories to next session</li>
      <li><strong>Track state:</strong> Maintains <code>~/.workers/*.json</code> files</li>
    </ul>
    
    <h3>Boundaries</h3>
    <ul>
      <li>Does not interpret agent output mid-session</li>
      <li>Does not modify prompts while agent is working</li>
      <li>Does not make decisions for agents</li>
      <li>Observes and coordinates only</li>
    </ul>
    
    <div class="card">
      <h3>Orchestrator actions by trigger</h3>
      <table>
        <tr><th>Trigger</th><th>Action</th></tr>
        <tr><td>Context limit reached</td><td>Cancel session, extract handoff, start next</td></tr>
        <tr><td>Agent outputs <code>DONE:</code></td><td>Mark worker complete, stop</td></tr>
        <tr><td>Agent outputs <code>HANDOFF:</code></td><td>Extract message, inject into next session</td></tr>
        <tr><td>Session interrupted</td><td>Extract last think blocks, inject into next session</td></tr>
        <tr><td>Max sessions reached</td><td>Mark worker as <code>max_reached</code>, stop</td></tr>
      </table>
    </div>

    <!-- QUICK REFERENCE -->
    <h2>Quick Reference</h2>
    
    <div class="card">
      <h3>Start autonomous work</h3>
      <pre><code># Start a worker loop
worker start myproject --task "implement feature X" --dir /path/to/project --max 20

# Monitor it
worker list
worker log myproject

# Steer by updating memory
curl -X POST https://deja.coey.dev/learn ...</code></pre>
    </div>
    
    <div class="card">
      <h3>Search past work</h3>
      <pre><code># What did we try before?
~/bin/shelley-search "websocket"
~/bin/shelley-recall "error TS2345"</code></pre>
    </div>
    
    <div class="card">
      <h3>Free up context</h3>
      <pre><code># Find and delete old messages
ctx search CONV_ID "big tool output"
ctx forget MSG_ID1 MSG_ID2
ctx size CONV_ID</code></pre>
    </div>

    <footer>
      <p>Built on <a href="https://exe.dev" style="color: var(--accent);">exe.dev</a> — VMs for agents</p>
    </footer>
  </div>

  <script>
    // Add copy buttons to code blocks
    document.querySelectorAll('pre').forEach(pre => {
      const btn = document.createElement('button');
      btn.className = 'copy-btn';
      btn.textContent = 'copy';
      btn.onclick = () => {
        navigator.clipboard.writeText(pre.querySelector('code').textContent);
        btn.textContent = 'copied!';
        setTimeout(() => btn.textContent = 'copy', 1500);
      };
      pre.appendChild(btn);
    });
  </script>
</body>
</html>
